"""
Utility for converting between different Solana private key formats
Handles conversion between raw bytes, Base58, and JSON formats
"""

import json
import os
import argparse
import logging
from typing import Dict, List, Tuple, Union, Optional
from pathlib import Path

from base58 import b58encode, b58decode
from nacl.signing import SigningKey, VerifyKey

def load_keypair_from_file(file_path: str) -> Tuple[bytes, bytes]:
    """
    Load a keypair from a JSON file generated by the vanity tool
    
    Args:
        file_path: Path to the JSON file
        
    Returns:
        Tuple: (private_key_bytes, public_key_bytes)
        
    Raises:
        ValueError: If the file is not valid
    """
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
        
        if not isinstance(data, list):
            raise ValueError("Invalid keypair file format: expected a list of integers")
        
        # First 32 bytes are the private key, rest is public key
        if len(data) < 32:
            raise ValueError("Invalid keypair file: too short")
        
        private_key = bytes(data[:32])
        public_key = bytes(data[32:64]) if len(data) >= 64 else None
        
        return private_key, public_key
    except json.JSONDecodeError:
        raise ValueError("Invalid JSON in keypair file")
    except Exception as e:
        raise ValueError(f"Failed to load keypair: {str(e)}")

def save_keypair_to_file(private_key: bytes, output_path: str) -> str:
    """
    Save a keypair to a JSON file in Solana format
    
    Args:
        private_key: Private key bytes
        output_path: Path to save the file
        
    Returns:
        str: Path to saved file
        
    Raises:
        ValueError: If the key is invalid
    """
    if len(private_key) != 32:
        raise ValueError(f"Invalid private key length: {len(private_key)}, expected 32")
    
    # Create signing key and extract public key
    signing_key = SigningKey(private_key)
    public_key = bytes(signing_key.verify_key)
    
    # Combine for Solana format
    keypair_data = list(private_key + public_key)
    
    try:
        os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
        with open(output_path, 'w') as f:
            json.dump(keypair_data, f)
        return output_path
    except Exception as e:
        raise ValueError(f"Failed to save keypair: {str(e)}")

def private_key_to_base58(private_key: bytes) -> str:
    """
    Convert a private key from bytes to Base58 string
    
    Args:
        private_key: Private key bytes
        
    Returns:
        str: Base58-encoded private key
    """
    return b58encode(private_key).decode()

def base58_to_private_key(base58_key: str) -> bytes:
    """
    Convert a Base58 private key to bytes
    
    Args:
        base58_key: Base58-encoded private key
        
    Returns:
        bytes: Private key bytes
        
    Raises:
        ValueError: If the key is invalid
    """
    try:
        private_key = b58decode(base58_key)
        if len(private_key) != 32:
            raise ValueError(f"Invalid private key length: {len(private_key)}, expected 32")
        return private_key
    except Exception as e:
        raise ValueError(f"Invalid Base58 key: {str(e)}")

def derive_public_key(private_key: bytes) -> bytes:
    """
    Derive a public key from a private key
    
    Args:
        private_key: Private key bytes
        
    Returns:
        bytes: Public key bytes
    """
    signing_key = SigningKey(private_key)
    return bytes(signing_key.verify_key)

def get_public_key_base58(private_key: bytes) -> str:
    """
    Get the Base58-encoded public key from a private key
    
    Args:
        private_key: Private key bytes
        
    Returns:
        str: Base58-encoded public key (Solana address)
    """
    public_key = derive_public_key(private_key)
    return b58encode(public_key).decode()

def convert_keypair_format(input_path: str, output_format: str, output_path: Optional[str] = None) -> Dict:
    """
    Convert a keypair file to the specified format
    
    Args:
        input_path: Path to the input keypair file
        output_format: Target format ('json', 'base58', 'raw', or 'display')
        output_path: Path for output file (if applicable)
        
    Returns:
        Dict: Information about the converted keypair
        
    Raises:
        ValueError: If the conversion fails
    """
    try:
        # Load the keypair
        private_key, _ = load_keypair_from_file(input_path)
        
        # Derive public key
        public_key = derive_public_key(private_key)
        public_key_base58 = b58encode(public_key).decode()
        
        # Create result info
        result = {
            "public_key": public_key_base58,
            "format": output_format
        }
        
        # Handle different output formats
        if output_format == 'json':
            # Save to JSON format (Solana CLI compatible)
            if not output_path:
                output_path = f"{public_key_base58}.json"
            save_keypair_to_file(private_key, output_path)
            result["file_path"] = output_path
            
        elif output_format == 'base58':
            # Convert to Base58 string
            private_key_base58 = private_key_to_base58(private_key)
            result["private_key"] = private_key_base58
            
            # Optionally save to file
            if output_path:
                with open(output_path, 'w') as f:
                    f.write(private_key_base58)
                result["file_path"] = output_path
                
        elif output_format == 'raw':
            # Output raw bytes (hex encoded for display)
            result["private_key_hex"] = private_key.hex()
            result["public_key_hex"] = public_key.hex()
            
            # Optionally save to file
            if output_path:
                with open(output_path, 'w') as f:
                    f.write(f"Private key: {private_key.hex()}\n")
                    f.write(f"Public key: {public_key.hex()}\n")
                result["file_path"] = output_path
                
        elif output_format == 'display':
            # Just return information for display, don't save file
            private_key_base58 = private_key_to_base58(private_key)
            result["private_key"] = private_key_base58
            result["private_key_hex"] = private_key.hex()
            result["public_key_hex"] = public_key.hex()
        
        else:
            raise ValueError(f"Unsupported output format: {output_format}")
        
        return result
    
    except Exception as e:
        raise ValueError(f"Conversion failed: {str(e)}")

def main():
    """Command-line interface for key conversion"""
    parser = argparse.ArgumentParser(description='Convert Solana keypair formats')
    parser.add_argument('input_file', help='Input keypair file in JSON format')
    parser.add_argument(
        '--format', '-f', 
        choices=['json', 'base58', 'raw', 'display'], 
        default='display',
        help='Output format (default: display)'
    )
    parser.add_argument(
        '--output', '-o',
        help='Output file path (optional)'
    )
    
    args = parser.parse_args()
    
    try:
        result = convert_keypair_format(args.input_file, args.format, args.output)
        
        # Display results
        print(f"Public Key (Solana Address): {result['public_key']}")
        
        if 'private_key' in result:
            print(f"Private Key (Base58): {result['private_key']}")
        
        if 'private_key_hex' in result:
            print(f"Private Key (Hex): {result['private_key_hex']}")
        
        if 'public_key_hex' in result:
            print(f"Public Key (Hex): {result['public_key_hex']}")
        
        if 'file_path' in result:
            print(f"Output saved to: {result['file_path']}")
            
    except ValueError as e:
        print(f"Error: {str(e)}")
        return 1
    
    return 0

if __name__ == '__main__':
    exit(main())